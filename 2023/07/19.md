## 日報 7/19 Happiness Chain 学習20日目

# 取り組んだ課題一覧 
### Gitの基本を身につける
- [x] もう怖くないGit！チーム開発で必要なGitを完全マスター
- [x] Gitによるバージョン管理 

   
# わかったこと
### Pull request, Github flow, mergeとrebaseの違い 

- [x] GitHub Flowの流れ
      
      ①master branchは常にデプロイできる状態に保っておく
      ②新しい開発や修正はmaster branchから新しいブランチをきって作業してコミットする
      ③定期的にpushする(他のチームメンバーが状況を把握するため)
      ④master branchにmergeするためにpull requestを行う
      ⑤必ずレビューを受ける
      ⑥master branchにmergeする
      ⑦デプロイする

- [x] Pull request

      プルリクエストは自分の変更したコードをリポジトリに取り込んでもらえるようにレビューしてもらって依頼すること。
      ①masterブランチを更新
      ②ブランチを作成
      ③ファイルを変更
      ④変更をコミット
      ⑤githubへpush
      ⑥プルリクエスト
      ⑦コードレビュー
      ⑧プルリクエストをマージ
      ⑨ブランチ削除

- [x] rebaseとは？

      変更をmergeとは異なる方法で統合するコマンドで、変更を統合するときに、履歴を綺麗に整えるもの
      git rebase ブランチ名 ※現在いるブランチにブランチ名に記載したブランチの変更を取り込む
      ただし、すでにリモートリポにpushしたあとにrebaseすると、その後pushできなくなるから注意
      rebaseすることにより親コミットが変わってしまうから

      
      
- [x] mergeとrebaseの違い

Merge（マージ）：
Mergeを行うと統合元ブランチの変更内容が統合先ブランチに統合され、新しいコミットが作成される。
マージコミットには、統合元と統合先ブランチの変更が含まれるため、マージ後の履歴には統合前の両方の変更が反映される。

Rebase（リベース）：
Rebaseを行うと、統合元ブランチのコミットが統合先ブランチの先頭に再適用され、新しいコミットが作成される。
つまり、リベースによって統合先ブランチには統合元ブランチの変更が直接移動するため、履歴が直線的になる。（Fast Forwardみたいな感じ）

まとめ :
両方、新しいコミットが作成される点は同じ。違いはそのコミットの内容と履歴にある。
Mergeでは両方のブランチの変更内容を保持したままコミットが作成されるが、rebaseでは統合元ブランチのコミットが統合先ブランチの直後になるため、履歴が直線的になりまって統合元ブランチの履歴は保持されない。
      
  

  
# 次やること
- [ ] Gitによるバージョン管理
- [ ] GitHub & Pull Request
      
# 感じたこと

+ mergeとrebaseの考え方に苦戦した
+ 実際の開発の流れでイメージしてみたが、「いつコミットするのか？というはっきりとした基準」があまりわかっていない気がする。
+ Gitはインプットの量が多いが、チーム開発ではGitが使えないと何もできないと言われるほど重要な要素なので、焦らず一歩ずつやっていく
  
  
  
  
  
# 学習時間

| 朝           | 日中          | 夜              | 計              |
| :----------|------------:|-------------:|-------------:|
| 1:30h           | 3h            | 3h              |  7:30h            |
